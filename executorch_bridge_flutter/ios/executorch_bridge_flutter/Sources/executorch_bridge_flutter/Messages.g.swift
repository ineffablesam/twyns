// Autogenerated from Pigeon (v17.3.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif


extension FlutterError: Error {}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
  return FlutterError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Configuration for model loading
///
/// Generated class from Pigeon that represents data sent in messages.
struct ModelConfig {
  var modelPath: String? = nil
  var tokenizerPath: String? = nil
  var specialTokens: [String?]? = nil

  static func fromList(_ list: [Any?]) -> ModelConfig? {
    let modelPath: String? = nilOrValue(list[0])
    let tokenizerPath: String? = nilOrValue(list[1])
    let specialTokens: [String?]? = nilOrValue(list[2])

    return ModelConfig(
      modelPath: modelPath,
      tokenizerPath: tokenizerPath,
      specialTokens: specialTokens
    )
  }
  func toList() -> [Any?] {
    return [
      modelPath,
      tokenizerPath,
      specialTokens,
    ]
  }
}

/// Configuration for text generation
///
/// Generated class from Pigeon that represents data sent in messages.
struct GenerationConfig {
  var sequenceLength: Int64? = nil
  var maximumNewTokens: Int64? = nil
  var temperature: Double? = nil
  var topP: Double? = nil

  static func fromList(_ list: [Any?]) -> GenerationConfig? {
    let sequenceLength: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let maximumNewTokens: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))
    let temperature: Double? = nilOrValue(list[2])
    let topP: Double? = nilOrValue(list[3])

    return GenerationConfig(
      sequenceLength: sequenceLength,
      maximumNewTokens: maximumNewTokens,
      temperature: temperature,
      topP: topP
    )
  }
  func toList() -> [Any?] {
    return [
      sequenceLength,
      maximumNewTokens,
      temperature,
      topP,
    ]
  }
}

/// Response from model operations
///
/// Generated class from Pigeon that represents data sent in messages.
struct ModelResponse {
  var success: Bool? = nil
  var error: String? = nil
  var message: String? = nil
  var loadTime: Double? = nil

  static func fromList(_ list: [Any?]) -> ModelResponse? {
    let success: Bool? = nilOrValue(list[0])
    let error: String? = nilOrValue(list[1])
    let message: String? = nilOrValue(list[2])
    let loadTime: Double? = nilOrValue(list[3])

    return ModelResponse(
      success: success,
      error: error,
      message: message,
      loadTime: loadTime
    )
  }
  func toList() -> [Any?] {
    return [
      success,
      error,
      message,
      loadTime,
    ]
  }
}

/// Token generation callback data
///
/// Generated class from Pigeon that represents data sent in messages.
struct TokenData {
  var token: String? = nil
  var tokenCount: Int64? = nil
  var tokensPerSecond: Double? = nil

  static func fromList(_ list: [Any?]) -> TokenData? {
    let token: String? = nilOrValue(list[0])
    let tokenCount: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))
    let tokensPerSecond: Double? = nilOrValue(list[2])

    return TokenData(
      token: token,
      tokenCount: tokenCount,
      tokensPerSecond: tokensPerSecond
    )
  }
  func toList() -> [Any?] {
    return [
      token,
      tokenCount,
      tokensPerSecond,
    ]
  }
}

/// Memory usage information
///
/// Generated class from Pigeon that represents data sent in messages.
struct MemoryInfo {
  var usedMemoryMB: Int64? = nil
  var availableMemoryMB: Int64? = nil

  static func fromList(_ list: [Any?]) -> MemoryInfo? {
    let usedMemoryMB: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let availableMemoryMB: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))

    return MemoryInfo(
      usedMemoryMB: usedMemoryMB,
      availableMemoryMB: availableMemoryMB
    )
  }
  func toList() -> [Any?] {
    return [
      usedMemoryMB,
      availableMemoryMB,
    ]
  }
}

private class ExecutorchApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return GenerationConfig.fromList(self.readValue() as! [Any?])
    case 129:
      return MemoryInfo.fromList(self.readValue() as! [Any?])
    case 130:
      return ModelConfig.fromList(self.readValue() as! [Any?])
    case 131:
      return ModelResponse.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class ExecutorchApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? GenerationConfig {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? MemoryInfo {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? ModelConfig {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? ModelResponse {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class ExecutorchApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return ExecutorchApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ExecutorchApiCodecWriter(data: data)
  }
}

class ExecutorchApiCodec: FlutterStandardMessageCodec {
  static let shared = ExecutorchApiCodec(readerWriter: ExecutorchApiCodecReaderWriter())
}

/// Platform interface for ExecuTorch operations
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol ExecutorchApi {
  /// Initialize the ExecuTorch runner with model and tokenizer
  func loadModel(config: ModelConfig, completion: @escaping (Result<ModelResponse, Error>) -> Void)
  /// Check if model is currently loaded
  func isModelLoaded() throws -> Bool
  /// Unload the current model
  func unloadModel() throws
  /// Generate text from prompt
  func generateText(prompt: String, config: GenerationConfig, completion: @escaping (Result<ModelResponse, Error>) -> Void)
  /// Stop ongoing text generation
  func stopGeneration() throws
  /// Get current memory usage
  func getMemoryInfo() throws -> MemoryInfo
  /// Validate if file exists at path
  func validateFilePath(path: String) throws -> Bool
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class ExecutorchApiSetup {
  /// The codec used by ExecutorchApi.
  static var codec: FlutterStandardMessageCodec { ExecutorchApiCodec.shared }
  /// Sets up an instance of `ExecutorchApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: ExecutorchApi?) {
    /// Initialize the ExecuTorch runner with model and tokenizer
    let loadModelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.executorch_bridge_flutter.ExecutorchApi.loadModel", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadModelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let configArg = args[0] as! ModelConfig
        api.loadModel(config: configArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      loadModelChannel.setMessageHandler(nil)
    }
    /// Check if model is currently loaded
    let isModelLoadedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.executorch_bridge_flutter.ExecutorchApi.isModelLoaded", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isModelLoadedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isModelLoaded()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isModelLoadedChannel.setMessageHandler(nil)
    }
    /// Unload the current model
    let unloadModelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.executorch_bridge_flutter.ExecutorchApi.unloadModel", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unloadModelChannel.setMessageHandler { _, reply in
        do {
          try api.unloadModel()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      unloadModelChannel.setMessageHandler(nil)
    }
    /// Generate text from prompt
    let generateTextChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.executorch_bridge_flutter.ExecutorchApi.generateText", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      generateTextChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let promptArg = args[0] as! String
        let configArg = args[1] as! GenerationConfig
        api.generateText(prompt: promptArg, config: configArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      generateTextChannel.setMessageHandler(nil)
    }
    /// Stop ongoing text generation
    let stopGenerationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.executorch_bridge_flutter.ExecutorchApi.stopGeneration", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopGenerationChannel.setMessageHandler { _, reply in
        do {
          try api.stopGeneration()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopGenerationChannel.setMessageHandler(nil)
    }
    /// Get current memory usage
    let getMemoryInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.executorch_bridge_flutter.ExecutorchApi.getMemoryInfo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMemoryInfoChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getMemoryInfo()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMemoryInfoChannel.setMessageHandler(nil)
    }
    /// Validate if file exists at path
    let validateFilePathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.executorch_bridge_flutter.ExecutorchApi.validateFilePath", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      validateFilePathChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pathArg = args[0] as! String
        do {
          let result = try api.validateFilePath(path: pathArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      validateFilePathChannel.setMessageHandler(nil)
    }
  }
}
private class ExecutorchFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return TokenData.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class ExecutorchFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? TokenData {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class ExecutorchFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return ExecutorchFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ExecutorchFlutterApiCodecWriter(data: data)
  }
}

class ExecutorchFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = ExecutorchFlutterApiCodec(readerWriter: ExecutorchFlutterApiCodecReaderWriter())
}

/// Flutter interface for receiving callbacks from platform
///
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol ExecutorchFlutterApiProtocol {
  /// Called when a new token is generated
  func onTokenGenerated(token tokenArg: TokenData, completion: @escaping (Result<Void, FlutterError>) -> Void)
  /// Called when generation is complete
  func onGenerationComplete(fullText fullTextArg: String, totalTokens totalTokensArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)
  /// Called when an error occurs
  func onError(error errorArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void)
}
class ExecutorchFlutterApi: ExecutorchFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return ExecutorchFlutterApiCodec.shared
  }
  /// Called when a new token is generated
  func onTokenGenerated(token tokenArg: TokenData, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.executorch_bridge_flutter.ExecutorchFlutterApi.onTokenGenerated"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([tokenArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Called when generation is complete
  func onGenerationComplete(fullText fullTextArg: String, totalTokens totalTokensArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.executorch_bridge_flutter.ExecutorchFlutterApi.onGenerationComplete"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([fullTextArg, totalTokensArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Called when an error occurs
  func onError(error errorArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.executorch_bridge_flutter.ExecutorchFlutterApi.onError"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
